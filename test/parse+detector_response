#!/usr/bin/env python3

"""a script to parse a detector from an INI file and then examine the antenna patterns
"""
__author__ = "Reed Essick (reed.essick@gmail.com)"

#-------------------------------------------------

import os

import numpy as np

import matplotlib
matplotlib.use("Agg")
from matplotlib import pyplot as plt
plt.rcParams['text.usetex'] = True

from argparse import ArgumentParser

### non-standard libraries
import gwdetectors

#-------------------------------------------------

parser = ArgumentParser()

parser.add_argument('--config', default='network.ini', type=str)

parser.add_argument('-f', '--frequency', required=True, default=[], type=float, action='append',
    help='plot the detector responses at this frequency. Should be specified in Hz.')

parser.add_argument('--num-grid-points', default=100, type=int)

parser.add_argument('-v', '--verbose', default=False, action='store_true')

parser.add_argument('--color-map', default='coolwarm', type=str)
parser.add_argument('-o', '--output-dir', default='.', type=str)
parser.add_argument('-t', '--tag', default='', type=str)

args = parser.parse_args()

os.makedirs(args.output_dir, exist_ok=True)

if args.tag:
    args.tag = "_"+args.tag

#-------------------------------------------------

### load detector network from a config file

network = gwdetectors.parse(args.config, verbose=args.verbose, exit_on_exception=True)

#-------------------------------------------------

freqs = np.array(args.frequency, dtype=float)

t0 = 0.0
azimuth = np.linspace(-np.pi, +np.pi, 2*args.num_grid_points)
pole = np.linspace(0, np.pi, args.num_grid_points)
psi = 0.0

shape = (2*args.num_grid_points, args.num_grid_points)

AZIMUTH, POLE = np.meshgrid(azimuth, pole, indexing='ij')
AZIMUTH = AZIMUTH.flatten()
POLE = POLE.flatten()

PSI = np.ones_like(POLE, dtype=float)*psi

for detector in network.detectors:
    if args.verbose:
        print('computing detector response for : '+detector.name)

    fp, fx, fvx, fvy, fb, fl = detector.response(freqs, t0, AZIMUTH, POLE, PSI, coord='geographic')

    for fnd, freq in enumerate(freqs):
        if args.verbose:
            print('  plotting freq=%.3f Hz'%(freq))

        # tensor modes
        Fp = np.transpose(fp[fnd].reshape(shape))
        Fx = np.transpose(fx[fnd].reshape(shape))

        # vector modes
        Fvx = np.transpose(fvx[fnd].reshape(shape))
        Fvy = np.transpose(fvy[fnd].reshape(shape))

        # scalar modes
        Fb = np.transpose(fb[fnd].reshape(shape))
        Fl = np.transpose(fl[fnd].reshape(shape))

        ### now plot

        fig = plt.figure(figsize=(20.0, 3.5))

        # plot RMS tensorial detector response for reference

        ax = plt.subplot(1,7,1, projection='mollweide')
        ax.pcolormesh(
            azimuth,
            0.5*np.pi - pole,
            (np.abs(Fp)**2 + np.abs(Fx)**2)**0.5,
#            vmin=0,
#            vmax=+1,
            rasterized=True,
            cmap=args.color_map,
        )
        ax.set_title('$\sqrt{|F_+|^2 + |F_\\times|^2}$')

        # iterate through individual polarizations
        for pnd, (F, label) in enumerate([
                (Fp, 'F_+'),
                (Fx, 'F_\\times'),
                (Fvx, 'F_x'),
                (Fvy, 'F_y'),
                (Fb, 'F_b'),
                (Fl, 'F_l'),
            ]):

            ax_amp = plt.subplot(2,7,2+pnd, projection='mollweide')
            ax_phs = plt.subplot(2,7,9+pnd, projection='mollweide')

            ax_amp.pcolormesh(
                azimuth,
                0.5*np.pi - pole,
                np.abs(F),
#                vmin=0,
#                vmax=+1,
                rasterized=True,
                cmap=args.color_map,
            )
            ax_amp.set_title('$|%s|$'%label)

            ax_phs.pcolormesh(
                azimuth,
                0.5*np.pi - pole,
                np.arctan2(F.imag, F.real),
#                vmin=-np.pi,
#                vmax=+np.pi,
                rasterized=True,
                cmap=args.color_map,
            )
            ax_phs.set_title('arg $%s$'%label)

        # plot arm directions

        for arm in detector.arms:
            nx, ny, nz = np.array(arm)/np.sum(np.array(arm)**2)**0.5
            p = np.arccos(nz)
            a = np.arctan2(ny, nx)

            for ax in fig.axes:
                ax.plot(a, 0.5*np.pi-p, marker='o', markeredgecolor='k', markerfacecolor='none')

        # decorate

        for ax in fig.axes:
            ax.grid(True)
            plt.setp(ax.get_xticklabels(), visible=False)
            plt.setp(ax.get_yticklabels(), visible=False)

        fig.suptitle('%.3f Hz'%freq)

        fig.text(0.02, 0.05, '$\psi=%.3f$'%psi, ha='left', va='bottom')

        plt.subplots_adjust(
            left=0.02,
            right=0.98,
            bottom=0.05,
            top=0.90,
            hspace=0.05,
            wspace=0.10,
        )

        # save
        figname = os.path.join(
            args.output_dir,
            os.path.basename(__file__)+args.tag+('-%s'%detector.name)+('-%.3f'%freq).replace('.','d') + '.png'
        )
        if args.verbose:
            print('    saving : '+figname)
        fig.savefig(figname)
        plt.close(fig)
